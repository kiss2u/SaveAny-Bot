package web

import (
	"fmt"
	"os"
	"path/filepath"

	"github.com/gofiber/fiber/v2"
)

type WizardConfigRequest struct {
	SessionID string `json:"session_id"`
}

type WizardGenerateRequest struct {
	SessionID string `json:"session_id"`
	OutputPath string `json:"output_path"`
}

func (s *Server) handleWizardGenerate(c *fiber.Ctx) error {
	var req WizardGenerateRequest
	if err := c.BodyParser(&req); err != nil {
		return c.Status(400).JSON(fiber.Map{"error": "invalid request"})
	}

	sessionI, ok := wizardSessions.Load(req.SessionID)
	if !ok {
		return c.Status(404).JSON(fiber.Map{"error": "session not found"})
	}
	session := sessionI.(*WizardSession)

	if session.Step != WizardStepConfirm && session.Step != WizardStepComplete {
		return c.Status(400).JSON(fiber.Map{"error": "not at confirm step"})
	}

	// Generate config content
	configContent := generateConfigTOML(session)

	// Determine output path
	outputPath := req.OutputPath
	if outputPath == "" {
		outputPath = "config.toml"
	}

	// Write to file
	err := os.WriteFile(outputPath, []byte(configContent), 0644)
	if err != nil {
		return c.Status(500).JSON(fiber.Map{"error": "failed to write config: " + err.Error()})
	}

	// Mark session as complete
	session.Step = WizardStepComplete
	wizardSessions.Store(req.SessionID, session)

	return c.JSON(fiber.Map{
		"status": "ok",
		"message": "Config saved to " + outputPath,
		"config": configContent,
	})
}

func (s *Server) handleWizardDownload(c *fiber.Ctx) error {
	sessionID := c.Query("session_id")
	if sessionID == "" {
		return c.Status(400).JSON(fiber.Map{"error": "session_id required"})
	}

	sessionI, ok := wizardSessions.Load(sessionID)
	if !ok {
		return c.Status(404).JSON(fiber.Map{"error": "session not found"})
	}
	session := sessionI.(*WizardSession)

	configContent := generateConfigTOML(session)
	
	c.Set("Content-Disposition", "attachment; filename=config.toml")
	c.Set("Content-Type", "application/x-toml")
	return c.SendString(configContent)
}

func generateConfigTOML(session *WizardSession) string {
	config := `# SaveAny-Bot Configuration
# Generated by Setup Wizard

# 语言设置
lang = "zh-Hans"

# 同时下载文件数
workers = 5

# 重试次数
retry = 3

# 线程数
threads = 4

# 流式传输模式
stream = false

[telegram]
token = "%s"

# Telegram API 配置 (使用默认)
# 如需自定义，请前往 https://my.telegram.org 获取
# app_id = 1025907
# app_hash = "452b0359b988148995f22ff0f4229750"

[aria2]
enable = false

# 存储列表
[[storages]]
name = "default"
type = "%s"
enable = true
`

	// Add storage-specific config
	storageConfig := generateStorageConfig(session.Storage, session.StorageCfg)
	config += storageConfig

	// Add user config
	config += fmt.Sprintf(`
# 用户列表
[[users]]
id = %d
storages = []
blacklist = true
`, session.UserID)

	return config
}

func generateStorageConfig(storageType string, cfg map[string]interface{}) string {
	switch storageType {
	case "local":
		basePath := "./downloads"
		if v, ok := cfg["base_path"].(string); ok && v != "" {
			basePath = v
		}
		return fmt.Sprintf(`base_path = "%s"
`, basePath)

	case "s3":
		endpoint := ""
		bucket := ""
		accessKey := ""
		secretKey := ""
		region := "us-east-1"

		if v, ok := cfg["endpoint"].(string); ok {
			endpoint = v
		}
		if v, ok := cfg["bucket"].(string); ok {
			bucket = v
		}
		if v, ok := cfg["access_key"].(string); ok {
			accessKey = v
		}
		if v, ok := cfg["secret_key"].(string); ok {
			secretKey = v
		}
		if v, ok := cfg["region"].(string); ok {
			region = v
		}

		return fmt.Sprintf(`endpoint = "%s"
bucket = "%s"
access_key = "%s"
secret_key = "%s"
region = "%s"
`, endpoint, bucket, accessKey, secretKey, region)

	case "alist":
		url := ""
		token := ""

		if v, ok := cfg["url"].(string); ok {
			url = v
		}
		if v, ok := cfg["token"].(string); ok {
			token = v
		}

		return fmt.Sprintf(`url = "%s"
token = "%s"
`, url, token)

	case "webdav":
		url := ""
		username := ""
		password := ""

		if v, ok := cfg["url"].(string); ok {
			url = v
		}
		if v, ok := cfg["username"].(string); ok {
			username = v
		}
		if v, ok := cfg["password"].(string); ok {
			password = v
		}

		return fmt.Sprintf(`url = "%s"
username = "%s"
password = "%s"
`, url, username, password)

	default:
		return ""
	}
}

// GetStorageConfigFields returns the required fields for each storage type
func (s *Server) handleWizardStorageFields(c *fiber.Ctx) error {
	storageType := c.Query("type")
	if storageType == "" {
		return c.Status(400).JSON(fiber.Map{"error": "type required"})
	}

	fields := getStorageFields(storageType)
	return c.JSON(fields)
}

func getStorageFields(storageType string) []map[string]interface{} {
	switch storageType {
	case "local":
		return []map[string]interface{}{
			{"name": "base_path", "label": "保存路径", "type": "text", "default": "./downloads"},
		}
	case "s3":
		return []map[string]interface{}{
			{"name": "endpoint", "label": "Endpoint", "type": "text", "placeholder": "s3.amazonaws.com"},
			{"name": "bucket", "label": "Bucket", "type": "text"},
			{"name": "access_key", "label": "Access Key", "type": "text"},
			{"name": "secret_key", "label": "Secret Key", "type": "password"},
			{"name": "region", "label": "Region", "type": "text", "default": "us-east-1"},
		}
	case "alist":
		return []map[string]interface{}{
			{"name": "url", "label": "Alist URL", "type": "text", "placeholder": "https://alist.example.com"},
			{"name": "token", "label": "Alist Token", "type": "password"},
		}
	case "webdav":
		return []map[string]interface{}{
			{"name": "url", "label": "WebDAV URL", "type": "text", "placeholder": "https://example.com/dav"},
			{"name": "username", "label": "Username", "type": "text"},
			{"name": "password", "label": "Password", "type": "password"},
		}
	default:
		return []map[string]interface{}{}
	}
}
